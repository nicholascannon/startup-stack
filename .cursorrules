# Fullstack TypeScript Monorepo Rules

## Architecture Overview

```
packages/
├── server/      # Express API (Clean Architecture)
├── frontend/    # React SPA (Vite + React Query)
└── shared/      # Shared types (API contracts)
```

- TypeScript with ESM (`type: "module"`)
- Biome for linting/formatting
- Vitest for testing
- Prisma or Drizzle for database ORM

---

## Code Style (STRICT)

| Rule | Backend | Frontend |
|------|---------|----------|
| Import extensions | `.js` (always) | None |
| Quotes | Single | Single |
| Indent | 2 spaces | 2 spaces |
| Semicolons | Always | Always |
| Line width | 120 chars | 120 chars |

```typescript
// Backend imports (ALWAYS .js extension)
import { Router } from 'express';
import { LOGGER } from '../lib/logger.js';
import type { ApiResponse } from '@my-app/shared';

// Frontend imports (NEVER extension)
import { useQuery } from '@tanstack/react-query';
import { Button } from '@/components/ui/button';
import type { GetTasksResponse } from '@my-app/shared/api/tasks';
```

**Additional rules:**
- `import type { ... }` for type-only imports
- `node:` prefix for Node.js built-ins: `import { join } from 'node:path'`
- NEVER use `null` — always use `undefined`. Convert third-party `null` to `undefined`
- NEVER use `any` — use `unknown` or proper types
- Run `npm run lint:fix` from repo root to fix formatting

---

## Backend Architecture

### Directory Structure

```
server/src/
├── api/
│   ├── api-controller.ts        # Root router, composes features
│   └── {feature}/
│       ├── {feature}-controller.ts
│       ├── {feature}-service.ts
│       ├── {feature}-repo.ts    # Interface definition
│       ├── {feature}-errors.ts  # Domain errors
│       ├── __tests__/
│       │   ├── {feature}-controller.test.ts
│       │   └── {feature}-service.test.ts
│       └── repositories/
│           ├── pg-{feature}-repo.ts
│           └── memory-{feature}-repo.ts
├── config/
│   ├── env.ts                   # Zod-validated config
│   └── testing.ts               # Test setup + mocks
├── lib/
│   ├── controller.ts            # Base Controller class
│   ├── errors.ts                # Generic errors (UnauthorizedError, etc.)
│   └── logger.ts                # LOGGER singleton
├── middleware/
│   ├── requires-auth.ts
│   ├── request-id.ts
│   └── generic-error-handler.ts
└── types/
    └── express.d.ts             # Express type extensions
```

### Layer Responsibilities

| Layer | Responsibility | Dependencies | Testing |
|-------|---------------|--------------|---------|
| Controller | HTTP only — validate, route, respond | Service | Supertest (happy path + key errors) |
| Service | ALL business logic | Repository interface | Exhaustive unit tests |
| Repository | Data access only | Database client | Rarely tested directly |

### Controller Pattern

```typescript
// api/task/task-controller.ts
import type { Request, Response, NextFunction } from 'express';
import { z } from 'zod';
import {
  createTaskSchema,
  type CreateTaskResponse,
  type GetTaskResponse,
  type GetTasksResponse,
  type TaskNotFoundResponse,
} from '@my-app/shared/api/tasks';
import { Controller } from '../../lib/controller.js';
import { requiresAuth, getUserId } from '../../middleware/requires-auth.js';
import { TaskNotFoundError } from './task-errors.js';
import type { TaskService } from './task-service.js';

export class TaskController extends Controller {
  constructor(private readonly taskService: TaskService) {
    super();
    this.router.get('/', requiresAuth, this.getTasks);
    this.router.post('/', requiresAuth, this.createTask);
    this.router.get('/:id', requiresAuth, this.getTask);
    this.router.use(this.errorHandler);
  }

  private getTasks = async (req: Request, res: Response) => {
    const ownerId = getUserId(req);
    const tasks = await this.taskService.getTasks(ownerId);
    return res.status(200).json<GetTasksResponse>({
      data: { tasks },
      meta: { requestId: req.requestId, timestamp: new Date().toISOString() },
    });
  };

  private createTask = async (req: Request, res: Response) => {
    // Use shared schema for validation (same schema used by frontend forms)
    const ownerId = getUserId(req);
    const data = createTaskSchema.parse(req.body);
    const task = await this.taskService.createTask(ownerId, data);
    return res.status(201).json<CreateTaskResponse>({
      data: { task },
      meta: { requestId: req.requestId, timestamp: new Date().toISOString() },
    });
  };

  // For validation only used on the backend, define schema locally (not shared with FE)
  private getTask = async (req: Request, res: Response) => {
    const ownerId = getUserId(req);
    const { id } = z.object({ id: z.uuid() }).parse(req.params);
    const task = await this.taskService.getTask(ownerId, id);
    return res.status(200).json<GetTaskResponse>({
      data: { task },
      meta: { requestId: req.requestId, timestamp: new Date().toISOString() },
    });
  };

  // Controller-level error handler for domain errors
  private errorHandler = (error: Error, req: Request, res: Response, next: NextFunction) => {
    if (error instanceof TaskNotFoundError) {
      return res.status(404).json<TaskNotFoundResponse>({
        error: { code: 'TASK_NOT_FOUND', message: error.message },
        meta: { requestId: req.requestId, timestamp: new Date().toISOString() },
      });
    }
    next(error);
  };
}
```

**Controller rules:**
- Extend `Controller` base class
- Private handlers as arrow functions (preserves `this`)
- Always `return res.status(...).json<TypedResponse>(...)`
- Always include `meta` with `requestId` and `timestamp`
- **Use shared Zod schemas** from `@my-app/shared/api/{feature}` for request body validation
- Define param/query schemas locally in controller (not shared with FE)
- Controller-level error handler for domain-specific errors

### Service Pattern

```typescript
// api/task/task-service.ts
import type { Task } from '@my-app/shared/api/tasks';
import { TaskNotFoundError } from './task-errors.js';
import type { TaskRepo } from './task-repo.js';

export class TaskService {
  constructor(private readonly taskRepo: TaskRepo) {}

  async getTasks(ownerId: string): Promise<Task[]> {
    return this.taskRepo.findByOwner(ownerId);
  }

  async getTask(ownerId: string, id: string): Promise<Task> {
    const task = await this.taskRepo.findById(ownerId, id);
    if (!task) throw new TaskNotFoundError(id);
    return task;
  }

  async createTask(ownerId: string, data: { title: string }): Promise<Task> {
    return this.taskRepo.create(ownerId, data);
  }
}
```

**Service rules:**
- Constructor takes repository interfaces (not concrete implementations)
- Throws domain-specific errors
- No HTTP concerns (no req/res)
- Pure business logic

### Repository Pattern

```typescript
// api/task/task-repo.ts (interface)
import type { Task } from '@my-app/shared/api/tasks';

export interface TaskRepo {
  findByOwner(ownerId: string): Promise<Task[]>;
  findById(ownerId: string, id: string): Promise<Task | undefined>;
  create(ownerId: string, data: { title: string }): Promise<Task>;
}
```

```typescript
// api/task/repositories/pg-task-repo.ts
import type { PrismaClient } from '@prisma/client';
import type { Task } from '@my-app/shared/api/tasks';
import type { TaskRepo } from '../task-repo.js';

export class PgTaskRepo implements TaskRepo {
  constructor(private readonly db: PrismaClient) {}

  async findById(ownerId: string, id: string): Promise<Task | undefined> {
    const task = await this.db.task.findFirst({ where: { id, ownerId } });
    return task ? this.toTask(task) : undefined;
  }

  async create(ownerId: string, data: { title: string }): Promise<Task> {
    const task = await this.db.task.create({ data: { ...data, ownerId } });
    return this.toTask(task);
  }

  // Map Prisma model to domain type
  private toTask(record: PrismaTask): Task {
    return {
      id: record.id,
      title: record.title,
      completed: record.completed,
      createdAt: record.createdAt.toISOString(),
    };
  }
}
```

```typescript
// api/task/repositories/memory-task-repo.ts (for testing)
import type { Task } from '@my-app/shared/api/tasks';
import type { TaskRepo } from '../task-repo.js';

export class MemoryTaskRepo implements TaskRepo {
  private tasks = new Map<string, Task & { ownerId: string }>();

  async findByOwner(ownerId: string): Promise<Task[]> {
    return [...this.tasks.values()].filter((t) => t.ownerId === ownerId);
  }

  async findById(ownerId: string, id: string): Promise<Task | undefined> {
    const task = this.tasks.get(id);
    return task?.ownerId === ownerId ? task : undefined;
  }

  async create(ownerId: string, data: { title: string }): Promise<Task> {
    const task = { id: crypto.randomUUID(), ...data, ownerId, completed: false, createdAt: new Date().toISOString() };
    this.tasks.set(task.id, task);
    return task;
  }
}
```

### Domain Errors

```typescript
// api/task/task-errors.ts
export class TaskNotFoundError extends Error {
  constructor(public readonly id: string) {
    super(`Task with id ${id} not found`);
    this.name = 'TaskNotFoundError';
  }
}
```

### Configuration

```typescript
// config/env.ts
import { z } from 'zod';

export const CONFIG = z
  .object({
    env: z.enum(['development', 'production', 'test']),
    port: z.string().transform(Number),
    db: z.object({
      url: z.string(),
    }),
    auth: z.object({
      secretKey: z.string(),
    }),
  })
  .parse({
    env: process.env.NODE_ENV,
    port: process.env.PORT,
    db: { url: process.env.DATABASE_URL },
    auth: { secretKey: process.env.AUTH_SECRET_KEY },
  });

export type Config = typeof CONFIG;
```

**Config rules:**
- Zod validation + transformation at module load
- Export `CONFIG` constant and `Config` type
- WHEN ADDING CONFIG: update `config/testing.ts` AND `docker-compose.yml`

### Middleware

```typescript
// middleware/requires-auth.ts
import type { Request, Response, NextFunction } from 'express';
import { getAuth } from '@clerk/express';
import { UnauthorizedError } from '../lib/errors.js';

export function requiresAuth(req: Request, _res: Response, next: NextFunction) {
  const { userId } = getAuth(req);
  if (!userId) return next(new UnauthorizedError());
  req.userId = userId;
  next();
}

export function getUserId(req: Request): string {
  if (!req.userId) throw new UnauthorizedError();
  return req.userId;
}
```

### Backend Testing

```typescript
// config/testing.ts
import { beforeEach, vi } from 'vitest';
import type { Config } from '../config/env.js';

// Silence logger
beforeEach(() => {
  vi.mock('../lib/logger.js');
});

// Auth mocking
export const TEST_USER_ID = 'user_test123';
const mockGetAuth = vi.fn();

export function mockAuthenticated(userId = TEST_USER_ID) {
  mockGetAuth.mockReturnValue({ userId });
}

export function mockUnauthenticated() {
  mockGetAuth.mockReturnValue({ userId: undefined });
}

vi.mock('@clerk/express', () => ({
  getAuth: (req: unknown) => mockGetAuth(req),
  clerkMiddleware: () => (_req: unknown, _res: unknown, next: () => void) => next(),
}));

// Test config
export const TEST_CONFIG: Config = {
  env: 'test',
  port: 8000,
  db: { url: 'postgresql://test:test@localhost:5432/test' },
  auth: { secretKey: 'test-secret' },
};

vi.mock('../config/env.js', () => ({ CONFIG: TEST_CONFIG }));
```

```typescript
// api/task/__tests__/task-controller.test.ts
import request from 'supertest';
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { mockAuthenticated, mockUnauthenticated, TEST_USER_ID } from '../../../config/testing.js';
import { createApp } from '../../../app.js';
import { MemoryTaskRepo } from '../repositories/memory-task-repo.js';

describe('TaskController', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('returns 200 with tasks', async () => {
    mockAuthenticated();
    const taskRepo = new MemoryTaskRepo();
    await taskRepo.create(TEST_USER_ID, { title: 'Test task' });
    const app = createApp({ taskRepo });

    const response = await request(app).get('/api/v1/tasks').expect(200);

    expect(response.body.data.tasks).toHaveLength(1);
    expect(response.body.meta.requestId).toBeDefined();
  });

  it('returns 401 when unauthenticated', async () => {
    mockUnauthenticated();
    const app = createApp({ taskRepo: new MemoryTaskRepo() });

    await request(app).get('/api/v1/tasks').expect(401);
  });
});
```

**Running tests (Agents MUST follow):**
- Server: `npm run server test -- --run` from repo root
- Frontend: `npm run frontend test -- --run` from repo root
- ALL: `npm run test -- --run` from repo root
- ALWAYS use `required_permissions: ["network"]` for server tests (Supertest binds ports)

---

## Shared Package

### Directory Structure

```
shared/src/
├── index.ts              # Exports types/api-response
├── types/
│   └── api-response.ts   # ApiResponse, ApiErrorResponse, type guards
└── api/
    ├── errors.ts         # Generic error responses
    └── {feature}.ts      # Feature-specific types + schemas
```

### API Response Types

```typescript
// types/api-response.ts
export type ApiResponse<TData> = {
  data: TData;
  meta?: {
    requestId: string;
    timestamp: string;
  };
};

export type ApiErrorResponse<TErrorCode extends string, TErrorDetails = unknown> = {
  error: {
    code: TErrorCode;
    message: string;
    details?: TErrorDetails;
  };
  meta: {
    requestId: string;
    timestamp: string;
  };
};

// Type guard with optional error code narrowing
export function isApiErrorResponse<TCode extends string>(error: unknown, code: TCode): error is ApiErrorResponse<TCode>;
export function isApiErrorResponse(error: unknown): error is ApiErrorResponse<string>;
export function isApiErrorResponse<TCode extends string>(
  error: unknown,
  code?: TCode
): error is ApiErrorResponse<TCode> {
  const isError = typeof error === 'object' && error !== null && 'error' in error && 'meta' in error;
  if (!isError) return false;
  if (code === undefined) return true;
  return (error as ApiErrorResponse<string>).error.code === code;
}
```

### Feature Types

```typescript
// api/tasks.ts
import { z } from 'zod';
import type { ApiErrorResponse, ApiResponse } from '../types/api-response.js';

export type Task = {
  id: string;
  title: string;
  completed: boolean;
  createdAt: string;
};

// Success responses
export type GetTasksResponse = ApiResponse<{ tasks: Task[] }>;
export type GetTaskResponse = ApiResponse<{ task: Task }>;
export type CreateTaskResponse = ApiResponse<{ task: Task }>;

// Error responses
export type TaskNotFoundResponse = ApiErrorResponse<'TASK_NOT_FOUND'>;

// Shared validation schemas (used by both FE and BE)
export const createTaskSchema = z.object({
  title: z.string().min(1),
});
export type CreateTaskSchema = z.infer<typeof createTaskSchema>;
```

### Shared Zod Schemas

Define validation schemas in `shared/src/api/{feature}.ts` that are used by **both** frontend and backend:

```typescript
// shared/src/api/{feature}.ts
import { z } from 'zod';

// Schema definition
export const createTaskSchema = z.object({
  title: z.string().min(1),
});

// Inferred type (always export alongside schema)
export type CreateTaskSchema = z.infer<typeof createTaskSchema>;
```

**Backend usage (controller validation):**
```typescript
// server/src/api/task/task-controller.ts
import { createTaskSchema } from '@my-app/shared/api/tasks';

private createTask = async (req: Request, res: Response) => {
  const data = createTaskSchema.parse(req.body);
  // ...
};
```

**Frontend usage (react-hook-form):**
```typescript
// frontend/src/pages/tasks/components/create-task-dialog.tsx
import { zodResolver } from '@hookform/resolvers/zod';
import { type CreateTaskSchema, createTaskSchema } from '@my-app/shared/api/tasks';

const { register, handleSubmit } = useForm<CreateTaskSchema>({
  resolver: zodResolver(createTaskSchema),
});
```

**Schema naming:**
- Schema: `{action}{Feature}Schema` (camelCase) — `createTaskSchema`, `addFileSchema`
- Type: `{Action}{Feature}Schema` (PascalCase) — `CreateTaskSchema`, `AddFileSchema`

```typescript
// api/errors.ts
import type { ApiErrorResponse } from '../types/api-response.js';

export type NotFoundResponse = ApiErrorResponse<'NOT_FOUND', { path: string; method: string }>;
export type UnauthorizedResponse = ApiErrorResponse<'UNAUTHORIZED'>;
export type InvalidRequestResponse = ApiErrorResponse<'INVALID_REQUEST', Record<string, string[]>>;
export type InternalServerErrorResponse = ApiErrorResponse<'INTERNAL_SERVER_ERROR'>;

export type ApiError =
  | NotFoundResponse
  | UnauthorizedResponse
  | InvalidRequestResponse
  | InternalServerErrorResponse;
```

### Import Pattern

```typescript
// Base types + type guards from package root
import { isApiErrorResponse } from '@my-app/shared';
import type { ApiResponse, ApiErrorResponse } from '@my-app/shared';

// Feature types + schemas from api/{feature}
import { createTaskSchema, type CreateTaskSchema } from '@my-app/shared/api/tasks';
import type { Task, GetTasksResponse, TaskNotFoundResponse } from '@my-app/shared/api/tasks';
import type { ApiError } from '@my-app/shared/api/errors';
```

**Note:** Import schemas as values (not `type`), import types with `type` keyword.

---

## Frontend Architecture

### Directory Structure

```
frontend/src/
├── app.tsx
├── router.tsx
├── main.tsx
├── index.css
├── components/
│   ├── ui/               # Reusable UI components (button, skeleton, etc.)
│   └── {feature}/        # Feature components with index.ts barrel
├── hooks/
│   └── use-{action}.ts   # API hooks (use-get-users.ts, use-create-user.ts)
├── pages/
│   └── {page}/
│       ├── index.ts
│       ├── {page}-page.tsx
│       └── components/   # Page-specific components
├── auth/
│   ├── index.ts
│   ├── components/
│   └── hooks/
├── lib/
│   ├── providers.tsx     # App providers (Query, Auth, Toast)
│   ├── query-client.ts
│   └── utils.ts          # cn() helper
└── config/
    └── env.ts
```

### API Hooks (React Query)

```typescript
// hooks/use-get-tasks.ts
import type { ApiError } from '@my-app/shared/api/errors';
import type { GetTasksResponse } from '@my-app/shared/api/tasks';
import { useQuery } from '@tanstack/react-query';

export function useGetTasks() {
  return useQuery<GetTasksResponse, Error | ApiError>({
    queryKey: ['tasks'],
    queryFn: getTasks,
  });
}

async function getTasks(): Promise<GetTasksResponse> {
  const response = await fetch('/api/v1/tasks');
  if (!response.ok) throw await response.json();
  return response.json();
}
```

```typescript
// hooks/use-create-task.ts
import type { ApiError } from '@my-app/shared/api/errors';
import type { CreateTaskResponse, CreateTaskSchema } from '@my-app/shared/api/tasks';
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { toast } from 'react-toastify';

export function useCreateTask() {
  const queryClient = useQueryClient();

  return useMutation<CreateTaskResponse, ApiError, CreateTaskSchema>({
    mutationFn: createTask,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['tasks'] });
      toast.success('Task created');
    },
  });
}

async function createTask(data: CreateTaskSchema): Promise<CreateTaskResponse> {
  const response = await fetch('/api/v1/tasks', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(data),
  });
  if (!response.ok) throw await response.json();
  return response.json();
}
```

```typescript
// hooks/use-get-task.ts (conditional query)
import { useQuery } from '@tanstack/react-query';

export function useGetTask(id?: string) {
  return useQuery({
    queryKey: ['task', id],
    queryFn: () => getTask(id!),
    enabled: !!id, // Only fetch when id exists
  });
}
```

**Hook patterns:**
- Separate fetch function from hook
- Query keys: `['tasks']`, `['task', id]`
- Mutations invalidate related queries
- Toast on success
- Throw JSON error for React Query error handling
- Use `enabled` for conditional queries

### Form Pattern (react-hook-form + shared Zod schema)

```typescript
// pages/tasks/components/create-task-dialog.tsx
import { zodResolver } from '@hookform/resolvers/zod';
import { type CreateTaskSchema, createTaskSchema } from '@my-app/shared/api/tasks';
import { useForm } from 'react-hook-form';
import { Button } from '@/components/ui/button';
import { Field, FieldError } from '@/components/ui/field';
import { Input } from '@/components/ui/input';
import { useCreateTask } from '@/hooks/use-create-task';

export function CreateTaskDialog() {
  const {
    register,
    handleSubmit,
    reset,
    formState: { errors },
  } = useForm<CreateTaskSchema>({
    resolver: zodResolver(createTaskSchema),
    defaultValues: { title: '' },
  });
  const { mutate: createTask, isPending } = useCreateTask();

  const onSubmit = (data: CreateTaskSchema) => {
    createTask(data, {
      onSuccess: () => reset(),
    });
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <Field>
        <Input type="text" placeholder="Task title" {...register('title')} />
        <FieldError>{errors.title?.message}</FieldError>
      </Field>
      <Button disabled={isPending} type="submit">Create</Button>
    </form>
  );
}
```

**Form patterns:**
- Use `zodResolver(sharedSchema)` for client-side validation matching backend
- Type form with `useForm<SchemaType>` using inferred type from shared schema
- Use `isApiErrorResponse(error, 'ERROR_CODE')` for type-safe error narrowing
- Map API errors to field errors via `setError('fieldName', { message })`
- Reset form on success with `reset()`

### Page Pattern

```typescript
// pages/home/home-page.tsx
import { AuthenticatedPage, useCurrentUser } from '@/auth';
import { TaskList } from './components/task-list';

function HomeContent() {
  const { user } = useCurrentUser();
  if (!user) return <div>Error loading user</div>;

  return (
    <div className="mx-8 flex flex-col gap-8">
      <h1 className="text-4xl">Welcome, {user.firstName}</h1>
      <TaskList />
    </div>
  );
}

export function HomePage() {
  return (
    <AuthenticatedPage>
      <HomeContent />
    </AuthenticatedPage>
  );
}
```

### Component Pattern

```typescript
// components/task-card.tsx
import type { Task } from '@my-app/shared/api/tasks';

type TaskCardProps = {
  task: Task;
  onToggle?: () => void;
  onDelete?: () => void;
};

export function TaskCard({ task, onToggle, onDelete }: TaskCardProps) {
  return (
    <div className="rounded-lg border p-4">
      <h3 className={task.completed ? 'line-through' : ''}>{task.title}</h3>
      <div className="flex gap-2">
        {onToggle && <button onClick={onToggle}>{task.completed ? 'Undo' : 'Complete'}</button>}
        {onDelete && <button onClick={onDelete}>Delete</button>}
      </div>
    </div>
  );
}
```

### Path Alias

```typescript
// Always use @/ for src imports
import { Button } from '@/components/ui/button';
import { useGetUsers } from '@/hooks/use-get-users';
import { AuthenticatedPage } from '@/auth';
```

---

## Naming Conventions

| Type | Convention | Example |
|------|------------|---------|
| Classes | PascalCase | `TaskController`, `TaskService` |
| Functions/variables | camelCase | `getTasks`, `isLoading` |
| Types/interfaces | PascalCase | `ApiResponse`, `TaskRepo` |
| React components | PascalCase | `TaskCard`, `HomePage` |
| Files | kebab-case | `task-controller.ts`, `use-get-tasks.ts` |
| Directories | kebab-case | `task-card/`, `api/` |
| Constants | UPPER_SNAKE_CASE | `CONFIG`, `LOGGER`, `TEST_USER_ID` |
| Error codes | SCREAMING_SNAKE_CASE | `'TASK_NOT_FOUND'`, `'UNAUTHORIZED'` |
| Hooks | camelCase with `use` prefix | `useGetTasks`, `useCreateTask` |
| Response types | `{Action}{Feature}Response` | `GetTasksResponse`, `CreateTaskResponse` |
| Error response types | `{Feature}{Error}Response` | `TaskNotFoundResponse` |
| Zod schemas | `{action}{Feature}Schema` (camelCase) | `createTaskSchema`, `addFileSchema` |
| Schema types | `{Action}{Feature}Schema` (PascalCase) | `CreateTaskSchema`, `AddFileSchema` |

---

## Import Order

```typescript
// 1. Node.js built-ins (with node: prefix)
import { join } from 'node:path';
import { randomUUID } from 'node:crypto';

// 2. External packages
import express from 'express';
import { z } from 'zod';

// 3. Internal packages (absolute)
import type { ApiResponse } from '@my-app/shared';
import type { Task } from '@my-app/shared/api/tasks';

// 4. Same package (relative, with .js on backend)
import { LOGGER } from '../lib/logger.js';
import { TaskService } from './task-service.js';
```

---

## Quick Reference

**Add new API feature:**
1. `shared/src/api/{feature}.ts` — types, response types, and Zod schemas
2. `server/src/api/{feature}/` — controller (uses shared schema), service, repo, errors
3. `frontend/src/hooks/use-{action}.ts` — Global React Query hooks
4. `frontend/src/pages/{page}/` — page component with components and hooks required only for this page

**Add new config value:**
1. `server/src/config/env.ts` — add to schema + parse
2. `server/src/config/testing.ts` — add to TEST_CONFIG
3. `docker-compose.yml` — add environment variable

**Response format (ALWAYS):**
```typescript
// Success
{ data: T, meta: { requestId, timestamp } }

// Error
{ error: { code, message, details? }, meta: { requestId, timestamp } }
```
